SOLID принципы

S ---- Single responsibility principle
O ---- Open-closed principle
L ---- Liskov substitution principle
I ---- Interface segregation principle
D ---- Dependency inversion principle

При создании программных систем использование принципов SOLID способствует созданию такой системы, которую будет легко поддерживать и расширять в течение долгого времени.
Принципы SOLID — это руководства, которые также могут применяться во время работы над существующим программным обеспечением для его улучшения, например, для удаления «дурно пахнущего кода».

Стратегии гибкой и адаптивной разработки предполагают написание кода с соблюдением принципов SOLID.

1. Single responsibility principle	
Принцип единственной ответственности

Принцип гласит, что может быть только одна причина, приводящая к изменению класса.
Другими словами, каждый класс должен иметь только одну ответственность, которая должна быть инкапсулирована в этом классе. 

Повышается:
    тестируемость; 
    читаемость;
    короткое и понятное описание класса;
    простота сопровождения.

2. Open-closed principle
Принцип открытости/закрытости

Классы должны быть открыты для расширения и одновременно закрыты для модификации.
Иными словами, должна быть возможность добавлять новые свойства и расширять класс без изменения внутренней реализации существующих свойств.
    «закрыт для модификации»
    «Открыт для расширений» 

3. Liskov substitution principle
Принцип подстановки Лисков

В объектно-ориентированном программировании является специфичным определением подтипа, предложенным Барбарой Лисков в 1987 году на конференции в основном докладе под названием Абстракция данных и иерархия.

Требует возможности использования любых порожденных классов на месте родительских.
При этом они должны обладать тем же поведением, что и родительские классы, без внесения изменений.
Этот принцип гарантирует, что порожденный класс не изменяет определение типа родительского и его поведение. 

4. Interface segregation principle
Принцип разделения интерфейса 

Клиенты не должны реализовывать интерфейсы, которые они не используют. 
Данный принцип требует разделения «толстых» интерфейсов на несколько специализированных, связанных общей функциональностью.

5. Dependency inversion principle
Принцип инверсии зависимостей

Модули высокого уровня не должны зависеть от модулей нижнего уровня.
И те, и другие должны зависеть от абстракций.
Абстракции не должны зависеть от деталей. 
Детали должны зависеть от абстракций.
